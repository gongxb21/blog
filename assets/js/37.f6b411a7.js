(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{223:function(t,a,i){"use strict";i.r(a);var s={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},n=i(5),e=Object(n.a)(s,function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[i("h1",{attrs:{id:"类加载过程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 类加载过程")]),t._v(" "),i("h2",{attrs:{id:"加载"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#加载","aria-hidden":"true"}},[t._v("#")]),t._v(" 加载")]),t._v(" "),i("p",[t._v("简单的说，类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 java.lang.Class 对象实例（Java 虚拟机规范并没有明确要求一定要存储在堆区中，只是 hotspot 选择将 Class 对戏那个存储在方法区中），这个 Class 对象在日后就会作为方法区中该类的各种数据的访问入口。")]),t._v(" "),i("h2",{attrs:{id:"链接"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#链接","aria-hidden":"true"}},[t._v("#")]),t._v(" 链接")]),t._v(" "),i("p",[t._v("链接阶段要做的是将加载到 JVM 中的二进制字节流的类数据信息合并到 JVM 的运行时状态中，经由验证、准备和解析三个阶段。")]),t._v(" "),i("ul",[i("li",[t._v("验证\n验证类数据信息是否符合 JVM 规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等。\n"),i("ul",[i("li",[t._v("格式验证：验证是否符合 class 文件规范。")]),t._v(" "),i("li",[t._v("语义验证：检查一个被标记为 final 的类型是否包含子类；检查一个类中的 final 方法视频被子类进行重写，确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）。")]),t._v(" "),i("li",[t._v("操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段进行，检查是否通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等。")])])]),t._v(" "),i("li",[t._v("准备\n为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内。被 final 修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在 ConstantValue 属性，则在准备阶段，其值就是 ConstantValue 的值。")]),t._v(" "),i("li",[t._v("解析\n将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些 final 方法(不可以重写),static 方法(只会属于当前类)，构造器(不会被重写)。")])]),t._v(" "),i("h2",{attrs:{id:"初始化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#初始化","aria-hidden":"true"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),i("p",[t._v("将一个类中所有被 static 关键字标识的代码统一执行一遍：")]),t._v(" "),i("ul",[i("li",[t._v("如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；")]),t._v(" "),i("li",[t._v("如果执行的是 static 代码块，那么在初始化阶段，JVM 就会执行 static 代码块中定义的所有操作。")])]),t._v(" "),i("p",[t._v("所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就 clinit 方法，即是类/接口初始化方法。该方法的作用就是初始化一个中的变量，使用用户指定的值覆盖之前在准备阶段里设定的初始值。任何 invoke 之类的字节码都无法调用 clinit 方法，因为该方法只能在类加载的过程中由 JVM 调用。如果父类还没有被初始化，那么优先对父类初始化，但在 clinit 方法内部不会显示调用父类的 clinit 方法，由 JVM 负责保证一个类的 clinit 方法执行之前，它的父类 clinit 方法已经被执行。JVM 必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。")])])},[],!1,null,null,null);e.options.__file="classloader.md";a.default=e.exports}}]);