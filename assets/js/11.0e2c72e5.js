(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{173:function(t,a,e){t.exports=e.p+"assets/img/jvm.2b1b3e2d.png"},234:function(t,a,e){"use strict";e.r(a);var r={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},v=e(5),i=Object(v.a)(r,function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[r("h1",{attrs:{id:"jvm-内存模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存模型","aria-hidden":"true"}},[t._v("#")]),t._v(" JVM 内存模型")]),t._v(" "),r("p",[r("img",{attrs:{src:e(173),alt:"jvm内存模型"}})]),t._v(" "),r("p",[t._v("方法区和堆是所有线程共享的内存区域；而 java 栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。")]),t._v(" "),r("ul",[r("li",[t._v("Java 堆（Heap）,是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。")]),t._v(" "),r("li",[t._v("方法区（Method Area）,方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。")]),t._v(" "),r("li",[t._v("程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。")]),t._v(" "),r("li",[t._v("JVM 栈（JVM Stacks）,与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。")]),t._v(" "),r("li",[t._v("本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。")])]),t._v(" "),r("h2",{attrs:{id:"对象分配规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象分配规则","aria-hidden":"true"}},[t._v("#")]),t._v(" 对象分配规则")]),t._v(" "),r("ul",[r("li",[t._v("对象优先分配在 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC。")]),t._v(" "),r("li",[t._v("大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。")]),t._v(" "),r("li",[t._v("长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1，知道达到阀值对象进入老年区。")]),t._v(" "),r("li")]),t._v(" "),r("p",[t._v("动态判断对象的年龄。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。\n空间分配担保。每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Monitor GC,如果 false 则进行 Full GC。")])])},[],!1,null,null,null);i.options.__file="jvm_model.md";a.default=i.exports}}]);