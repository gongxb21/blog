(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{204:function(e,t,r){"use strict";r.r(t);var i={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},l=r(5),v=Object(l.a)(i,function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.slotKey}},[r("h1",{attrs:{id:"redis-为何支持高并发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-为何支持高并发","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis\b\b 为何支持高并发")]),e._v(" "),r("h2",{attrs:{id:"基本原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 基本原理")]),e._v(" "),r("ul",[r("li",[e._v("采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）")])]),e._v(" "),r("ol",[r("li",[r("p",[e._v("为什么不采用多进程或多线程处理？")]),e._v(" "),r("ul",[r("li",[e._v("多线程处理可能涉及到锁")]),e._v(" "),r("li",[e._v("多线程处理会涉及到线程切换而消耗 CPU")])])]),e._v(" "),r("li",[r("p",[e._v("单线程处理的缺点？")]),e._v(" "),r("ul",[r("li",[e._v("无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善")])])])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Redis 不存在线程安全问题？")]),e._v(" "),r("p",[e._v("Redis 采用了线程封闭的方式，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个 redis 操作的复合操作来说，依然需要锁，而且有可能是分布式锁")])]),e._v(" "),r("li",[r("p",[e._v("什么是多路 I/O 复用（Epoll）")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("网络 IO 都是通过 Socket 实现，Server 在某一个端口持续监听，客户端通过 Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用 Socket 中封装的 InputStream 和 OutputStream 进行 IO 交互了。针对每个客户端，Server 都会创建一个新线程专门用于处理")])]),e._v(" "),r("li",[r("p",[e._v("默认情况下，网络 IO 是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的 IO 事件")])]),e._v(" "),r("li",[r("p",[e._v("为了提升服务器线程处理效率，有以下三种思路")]),e._v(" "),r("ul",[r("li",[e._v("非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有 IO 事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致 CPU 空转")]),e._v(" "),r("li",[e._v("Select 代理（无差别轮询）：可以观察多个流的 IO 事件，如果所有流都没有 IO 事件，则将线程进入阻塞状态，如果有一个或多个发生了 IO 事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为 N，则时间复杂度为 O（N）")]),e._v(" "),r("li",[e._v("Epoll 代理：Select 代理有一个缺点，线程在被唤醒后轮询所有的 Stream，还是存在无效操作。 Epoll 会哪个流发生了怎样的 I/O 事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了 O(1)")])])])])]),e._v(" "),r("li",[r("p",[e._v("其它开源软件采用的模型")]),e._v(" "),r("ul",[r("li",[e._v("Nginx：多进程单线程模型")]),e._v(" "),r("li",[e._v("Memcached：单进程多线程模型")])])])]),e._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/liupeng_qwert/article/details/77263187",target:"_blank",rel:"noopener noreferrer"}},[e._v("whuruby 的 CSDN"),r("OutboundLink")],1)])])])},[],!1,null,null,null);v.options.__file="redis.md";t.default=v.exports}}]);