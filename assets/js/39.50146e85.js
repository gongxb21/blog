(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{250:function(t,e,s){"use strict";s.r(e);var r={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},a=s(5),n=Object(a.a)(r,function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[s("h1",{attrs:{id:"junit-不执行带-test-注解的用例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#junit-不执行带-test-注解的用例","aria-hidden":"true"}},[t._v("#")]),t._v(" JUNIT 不执行带@Test 注解的用例")]),t._v(" "),s("p",[t._v("前段时间，以救火队员的身份去帮助公司的测试小组写自动化测试项目。对于这个自动化测试项目，准确来说应该算接口的自动化测试。")]),t._v(" "),s("h2",{attrs:{id:"发现问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发现问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 发现问题")]),t._v(" "),s("p",[t._v("很快我就发现，公司自己封装的项目体系是不能使用@Test，@Before、@After 注解的，所有的方法都需要以 test 开头，比如 testSaveUser……心里想着，这不是 Junit3.x 的写法吗？然后我去看了项目所引用的 Junit 版本的确是 4.1.2。当时我也没有时间去深究到底为什么，先按照现有的这种写法写吧，但是个人的习惯还是让我给自己写的用例添加了@Test 注解。")]),t._v(" "),s("h2",{attrs:{id:"解决问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决问题")]),t._v(" "),s("p",[t._v("项目快结束的时候，终于有时间去解决这些遗留的问题了。我发现在封装的底层方法中继承了 TestCase 这个类，这个是 Junit3.x 中的写法啊，问题可能就是合理了。大胆的去把这个 TestCase 去掉，然后去执行所有的用例，果然只有我写的用例执行了。跟测试组的大佬交流之后，他知道这个问题，但是一直不知道怎么解决，我就这样解决了一个遗留问题：）")]),t._v(" "),s("h2",{attrs:{id:"问题总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 问题总结")]),t._v(" "),s("p",[t._v("下面概括下 Junit 注解的含义：")]),t._v(" "),s("ul",[s("li",[t._v("@Test: 要执行的用例，只有添加了这个注解，用例才会被执行；")]),t._v(" "),s("li",[t._v("@Ignore: 不执行的用例，只要添加了这个注解，用例就不会被执行；")]),t._v(" "),s("li",[t._v("@Before :在方法执行之前执行，类似 Junit3.x 中 setUp 方法；")]),t._v(" "),s("li",[t._v("@After：在方法执行之后执行，类似于 Junit3.x 中的 tearDown 方法；")]),t._v(" "),s("li",[t._v("@BeforeClass：在所有的方法执行前执行；")]),t._v(" "),s("li",[t._v("@AfterClass：在所有方法后执行；")])]),t._v(" "),s("p",[t._v("一个完整的用例的执行顺序：")]),t._v(" "),s("p",[s("strong",[t._v("@BeforeClass ->@Before->@Test->@After ->@AfterClass")])]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://blog.csdn.net/gxb2260/article/details/80934629",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么 Junit 单元测试不能执行带@Test 的用例"),s("OutboundLink")],1)])])])},[],!1,null,null,null);n.options.__file="junit.md";e.default=n.exports}}]);