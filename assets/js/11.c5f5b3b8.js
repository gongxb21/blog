(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{173:function(t,a,r){t.exports=r.p+"assets/img/mark-settle.54947b16.png"},245:function(t,a,r){"use strict";r.r(a);var e={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},s=r(5),i=Object(s.a)(e,function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[e("h1",{attrs:{id:"标记整理算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 标记整理算法")]),t._v(" "),e("p",[t._v('"标记-整理"（Mark-Compact）算法是根据老年代的特点提出的。')]),t._v(" "),e("h2",{attrs:{id:"算法思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法思路","aria-hidden":"true"}},[t._v("#")]),t._v(" \b 算法思路")]),t._v(" "),e("ul",[e("li",[e("p",[t._v('标记\n标记过程与"标记-清除"算法一样；')])]),t._v(" "),e("li",[e("p",[t._v("整理\n但后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动；然后直接清理掉端边界以外的内存；")])])]),t._v(" "),e("p",[t._v("执行过程如下图：\n"),e("img",{attrs:{src:r(173),alt:"标记整理算法"}})]),t._v(" "),e("h2",{attrs:{id:"算法优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法优点","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法优点")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("不会像复制算法，效率随对象存活率升高而变低，因为老年代\n对象存活率高，没有额外的空间可以分配担保；所以老年代一般不能直接选用复制算法算法；而选用标记-整理算法；")])]),t._v(" "),e("li",[e("p",[t._v("不会像标记-清除算法，产生内存碎片\n因为清除前，进行了整理，存活对象都集中到空间一侧；")])])]),t._v(" "),e("h2",{attrs:{id:"算法缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法缺点")]),t._v(" "),e("p",[t._v("主要是效率问题：除像标记-清除算法的标记过程外，还多了需要整理的过程，效率更低；")]),t._v(" "),e("h2",{attrs:{id:"应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),e("p",[t._v("很多垃圾收集器采用这种算法来回收老年代；")]),t._v(" "),e("p",[t._v("如 Serial Old 收集器、G1（从整体看）；")]),t._v(" "),e("hr")])},[],!1,null,null,null);i.options.__file="\b标记整理算法.md";a.default=i.exports}}]);