(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{229:function(t,e,n){"use strict";n.r(e);var s={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},r=n(5),o=Object(r.a)(s,function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[n("h1",{attrs:{id:"引用计数算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法","aria-hidden":"true"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://blog.csdn.net/gxb2260/article/details/78278889",target:"_blank",rel:"noopener noreferrer"}},[t._v("引用计数算法"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("很多教科书判断对象是否存活的算法是这样的，给对象中添加一个引用计数器，每当有一个地方引用他时，计数器的只就+1；每当引用失效时，计数器的致就-1；任何时刻计数器为 0 的对象就是不可能再被使用的。")]),t._v(" "),n("p",[t._v("客观的说，引用计数算法的实现简单，判定的效率也很高，在大部分的情况下都是一个不错的算法，但是主流的 Java 虚拟机中没有选用应用计数法来管理内存，起主要原因是他很难解决对象之间相互引用的问题。")])])},[],!1,null,null,null);o.options.__file="引用计数法.md";e.default=o.exports}}]);