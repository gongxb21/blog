(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{174:function(t,a,e){t.exports=e.p+"assets/img/mark-sweep.8ff27720.png"},211:function(t,a,e){"use strict";e.r(a);var s={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},r=e(5),i=Object(r.a)(s,function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[s("h1",{attrs:{id:"标记-清除算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 标记-清除算法")]),t._v(" "),s("p",[t._v("标记-清除（Mark-Sweep）算法是一种基础的收集算法。主要可以分为标记和清除 \b 两个 \b 步骤。")]),t._v(" "),s("h2",{attrs:{id:"算法思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法思路","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法思路")]),t._v(" "),s("ol",[s("li",[t._v("标记")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v('首先标记出所有需要回收的对象；\n标记过程如《Java 虚拟机垃圾回收(一) 基础》"2-4、判断对象生存还是死亡"中所述--分为两个标记过程：')]),t._v(" "),s("p",[t._v("1.第一次标记")]),t._v(" "),s("p",[t._v("在可达性分析后发现对象到 GC Roots 没有任何引用链相连时，被第一次标记；并且进行一次筛选：此对象是否必要执行 finalize()方法；对有必要执行 finalize()方法的对象，被放入 F-Queue 队列中；")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("第二次标记")])]),t._v(" "),s("p",[t._v('GC 将对 F-Queue 队列中的对象进行第二次小规模标记；在其 finalize()方法中重新与引用链上任何一个对象建立关联，第二次标记时会将其移出"即将回收"的集合；')])])]),t._v(" "),s("p",[t._v('对第一次被标记，且第二次还被标记（如果需要，但没有移出"即将回收"的集合），就可以认为对象已死，可以进行回收。')]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("清除")]),t._v(" "),s("p",[t._v('两次标记后，还在"即将回收"集合的对象将被统一回收；')]),t._v(" "),s("p",[s("img",{attrs:{src:e(174),alt:"执行过程"}})])])]),t._v(" "),s("h2",{attrs:{id:"算法优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法优点","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法优点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("基于最基础的可达性分析算法，它是最基础的收集算法；")])]),t._v(" "),s("li",[s("p",[t._v("而后续的收集算法都是基于这种思路并对其不足进行改进得到的；")])])]),t._v(" "),s("h2",{attrs:{id:"算法缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法缺点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("效率问题\n标记和清除两个过程的效率都不高；")])]),t._v(" "),s("li",[s("p",[t._v("空间问题\n标记清除后会产生大量不连续的内存碎片；这会导致分配大内存对象时，无法找到足够的连续内存；从而需要提前触发另一次垃圾收集动作；")])])]),t._v(" "),s("h2",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" \b 应用场景")]),t._v(" "),s("p",[t._v("针对老年代的 CMS 收集器；")])])},[],!1,null,null,null);i.options.__file="标记清除算法.md";a.default=i.exports}}]);